# Лабораторная работа 2
1. Итак мы хотим, чтобы скрипт обеспечивал принятый на вход IPv4-адрес в двоичном формате.
Для начала добавим функцию, которая позволяет проверить корректность введённого IP-адреса:
```
validate_ip() {
    local ip=$1
    IFS="." read -r -a octets <<< "$ip"

    if [ "${#octets[@]}" -ne 4 ]; then  
        return 1 # Некорректный IP
    fi

    for octet in "${octets[@]}"; do
        if [ "$octet" -lt 0 ] || [ "$octet" -ge 256 ]; then
            return 1  
        fi
    done
    return 0  
}
```
Внутри данной функции мы считываем введённый IP, разделяем его на октеты и записываем все октеты в массив, а затем проверяем количество октетов и соответствие цифр, которые содержит каждый октет (они должны входить в отрезок от 0 до 255).


2. Далее напишем функцию, которая конвертирует каждый октет из десятичного формата в двоичный:
```
convert_to_binary() {
    echo "obase=2; $1" | bc
}
```

Таким образом, когда функция `convert_to_binary` вызывается с числом в качестве аргумента, она выводит это число в двоичном формате. Внутри функции
`echo` генерирует строку с командой для `bc`, а затем результат этой команды выводится на экран.

3. Основной блок скрипта включает в себя ввод IP пользователем и вызов ранее определённых функций для получения конечного результата.
```
read -p "Введите ваш IP: " ip

if validate_ip "$ip"; then
    IFS="." read -r octet1 octet2 octet3 octet4 <<< "$ip"

    for octet in "${octets[@]}";
        do
                binary_octet=$(convert_to_binary "$octet")
                binary_result+="$binary_octet."
        done
        echo "${binary_result%.}"
else
    echo "Неверный IP"
fi
```
Далее проверим работу программы:
Случай 1: IP введён верно
![image](good)

Случай 2: IP введён неверно
![image](bad)
